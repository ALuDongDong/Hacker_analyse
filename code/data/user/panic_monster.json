{"user": "panic_monster", "history": ["Basics and lifecycle of a VM - Part #0EditAdded navigation linkssome restructuring in the link sectionDisclaimer This article is based on extensive research and I am not an expert in this field. The only intention I\u2019ve got was \u201cto understand how virtualization is working and share it\u201d (a pretty&hellip;", "The VMCS - Part #1EditAdded disclaimer and linksAdded navigation linksDisclaimer This article is based on extensive research and I am not an expert in this field. The only intention I\u2019ve got was \u201c to understand how virtualization is working and share it \u201d (a pretty naive target). Please tell me&hellip;", "Hey guys, back with just another casual article from me this time around since one of my projects failed miserably and I don\u2019t really have the time for another serious one. Also I\u2019ve getting into something new, as you may have already guessed, kernel-mode development! Yeah, pretty exciting stuff and&hellip;", "Here\u2019s all the malware I\u2019ve been collecting from my honeypot. Enjoy the Park! [image]", "IntroductionThis paper is how to setup your own Honeypot (dionaea). I would say most of us like Reverse Engineering binaries. Many of us have a fascination with malware. Why not combine them and RE some Malware that\u2019s actively being used for exploitation? My tutorial is how to setup a honeypot on &hellip;", "Surely you can force inline a function but that doesn\u2019t always generate efficient code. Macro substitution happens in the preprocessing phase whereas inline substitution takes place in the compilation phase. This often makes a difference. Case 1: Inline function#include &lt;stdio.h&gt;inline int __att&hellip;", "Surely you can force inline a function but that doesn\u2019t always generate efficient code. Macro substitution happens in the preprocessing phase whereas inline substitution takes place in the compilation phase. This often makes a difference. Case 1: Inline function#include &lt;stdio.h&gt;inline int __att&hellip;", "But you could do \u2018inline __attribute__((always_inline))\u2019 in gcc and it will always inline the function.", "inline is just a hint to the compiler. The compiler may or may not inline the function marked as such. Using a macro guarantees the code will be inline.", "There\u2019s the exploit-excercises website, it\u2019s pretty good, done a few of them.", "Awesome tutorials on the exploit development category. Can we also have challenges on these topics, that would allow us to practice these concepts hands on.", "Hey folks! this topic details how to overflow a buffer, bypass DEP (Data Execution Prevention) and take control of the executable Recommended PrerequisitesC/C++ language, a basic level would be finex86 Intel AssemblyFamiliarity with Buffer OverflowDebuggers/DisassemblyThe binaryFile Virust&hellip;", "My Introduction First, I would like to thank 0x00sec for providing such a great community. I would also like to thank Arrogant Bastard, Sierra Nevada and Deathwish Coffee for providing the sustenance necessary for starting and completing the following series. Not only should you get drunk while com&hellip;", "Great challenge. Flag: ARM{FL4G_PR0C33S1NG}Python 2.7 solver: from __future__ import print_functionimport binasciipart1 = 0x12345678 ^ 0x69790439part2 = 0xC2819E87 - part1part3 = (part2 + 0xE91E0419) &amp; 0xffffffffpart4 = (part3 - 0xDD1F1D1C) &amp; 0xffffffffpart5 = (0xD07A8174 - part4) &amp; 0&hellip;", "ARM Crackme - Data Processing@Wunkolo and I have decided that there aren\u2019t enough ARM crackmes on the forum and that we should add a few for people that are interested in learning how the architecture works and for those that just want to show their skills  We will start very easy with some challe&hellip;", "Great challenge. Flag: ARM{FL4G_PR0C33S1NG}Python 2.7 solver: from __future__ import print_functionimport binasciipart1 = 0x12345678 ^ 0x69790439part2 = 0xC2819E87 - part1part3 = (part2 + 0xE91E0419) &amp; 0xffffffffpart4 = (part3 - 0xDD1F1D1C) &amp; 0xffffffffpart5 = (0xD07A8174 - part4) &amp; 0&hellip;", "Good challenge. A great way to learn foreign archs. A one-liner python solution.     &#39;&quot;&quot;.join(map(lambda x: chr(int(x, 16)^0x5c), \u201c1D 0E 11 27 0F 6D 11 0C 10 6F 03 6F 6C 0E 21\u201d.split()))", "Good challenge. A great way to learn foreign archs. A one-liner python solution.     &#39;&quot;&quot;.join(map(lambda x: chr(int(x, 16)^0x5c), \u201c1D 0E 11 27 0F 6D 11 0C 10 6F 03 6F 6C 0E 21\u201d.split()))", "Sup folks! I hope you are all doing great. It\u2019s been a long time since my last CTF write-up. The main reason is because I was trying to master the beast called heap exploitation and I\u2019ve yet to learn a ton about it. To showcase one of the modern ways to pwn a heap-based vulnerable binary, I\u2019ll use a&hellip;"]}